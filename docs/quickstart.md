# Quick Start

Assuming we want to develop an application for the GraphQL Schema below:
```graphql
schema {
  query: Queries
}

enum Origin {
  EARTH
  MARS
  BELT
}

input NestedArgInput {
  id: String!
  name: String
}

type CharacterOutput {
  name: String!
  origin: Origin!
}

type Queries {
  characters(origin: Origin, nestedArg: NestedArgInput): [CharacterOutput!]
}
```

## Java21 Example

SymphonyQL uses APT (Annotation Processing Tool) to automatically generate schema definitions during compilation,
therefore, you only need to write record class to define the schema:
```java
@ObjectSchema(withArgs = true)
record Queries(Function<FilterArgs, Source<CharacterOutput, NotUsed>> characters) {
}

@ObjectSchema
record CharacterOutput(String name, Origin origin) {
}

@InputSchema
@ArgExtractor
record FilterArgs(Optional<Origin> origin, Optional<NestedArg> nestedArg) {
}

@InputSchema
@ArgExtractor
record NestedArg(String id, Optional<String> name) {
}

@EnumSchema
@ArgExtractor
enum Origin {
  EARTH,
  MARS,
  BELT
}
```

No need to write anything else, let's start developing the application now:
```java
    public static void main(String[] args) {
        var graphql = SymphonyQL
                .newSymphonyQL()
                .addQuery(
                        new Queries(
                                args1 -> Source.single(new CharacterOutput("hello-" + args1.origin().map(Enum::toString).get(), args1.origin().get()))
                        ),
                        QueriesSchema.schema
                )
                .build();
        System.out.println(graphql.render());

        var characters = """
                  {
                  characters(origin: "BELT") {
                    name
                    origin
                  }
                }""";

        final var actorSystem = ActorSystem.create("symphonyActorSystem");

        var getRes = graphql.run(
                SymphonyQLRequest.newRequest().query(Optional.of(characters)).build(),
                actorSystem
        );

        getRes.whenComplete((resp, throwable) -> System.out.println(resp.toOutputValue()));
        getRes.thenRun(() -> actorSystem.terminate());
    }
```

`QueriesSchema.schema` is automatically generated by APT and only needs to be used directly.

## Scala3 Example

Similarly, in Scala, you only need to use the case class to define the schema.
```scala
enum Origin {
  case EARTH, MARS, BELT
}

case class Character(name: String, origin: Origin)
case class FilterArgs(origin: Option[Origin])
case class NestedArg(id: String, name: Optional[String])
case class Queries(characters: FilterArgs => Source[Character, NotUsed])
```

SymphonyQL uses metaprogramming to automatically generate schema during compilation:
```scala
def main(args: Array[String]): Unit = {
    val graphql: SymphonyQL = SymphonyQL
    .newSymphonyQL()
    .addQuery(
      Queries(args =>
        Source.single(
          Character("hello-" + args.origin.map(_.toString).getOrElse(""), args.origin.getOrElse(Origin.BELT))
        )
      ),
      // generate schema
      Schema.derived[Queries]
    )
    .build()
    
    println(graphql.render)
    
    val characters =
    """{
      |  characters(origin: "MARS") {
      |    name
      |    origin
      |  }
      |}""".stripMargin
      
    implicit val actorSystem: ActorSystem                   = ActorSystem("symphonyActorSystem")
    val getRes: Future[SymphonyQLResponse[SymphonyQLError]] = graphql.runWith(SymphonyQLRequest(Some(characters)))
    println(Await.result(getRes, Duration.Inf).toOutputValue)
    actorSystem.terminate()
}
```

`Schema.derived[Queries]` is an inline call by metaprogramming.